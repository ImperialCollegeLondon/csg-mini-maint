#!/usr/bin/perl

=head1 NAME

minimaint

=head1 SYNOPSIS

minimaint --list [other options]
minimaint [other script options] scriptname scriptname...

=head1 DESCRIPTION

Runs all the maint scripts, or just scriptnames provided (dropping the numeric
prefix).  eg 'minimaint dist' runs the "dist" minimaint script.
Reads configuration information from /etc/minimaint by default,
or $ENV{MM_CONFIG_DIR} if it's set.

=head2 Options

  --help||usage       - Display help screen
  --[no]debug         - Print extra information
  --[no]dry-run       - Don't really do stuff, just go through the motions
  --[no]silent        - Don't print anything but warnings and errors
  --[no]logperline    - Display log message one per line (default no)
  --[no]colour        - Display log message with colour (default yes)
  --[no]machineread   - Makes logs machine readable
  --list              - Display all scriptnames and exit
  --mode=boot
         cron-15
         cron-30
         cron-60
	 cron-0300hrs
	 cron-0400hrs
         install
         manual          - Set the run "mode"
  --trace=none|caller|stack
                      - sets trace mode
=cut

# --- Compiler directives ---------------------------------------------------

use strict;
use warnings;
use File::Spec;
use File::Basename;
use File::Slurp;
use File::Path;
use JSON;
use Cwd qw(abs_path);
use Data::Dumper;
use Getopt::Long qw(:config gnu_getopt pass_through);

# --- Constants -------------------------------------------------------------

# DCW: THESE NEED TO MOVE INTO CONFIG OR BE DELETED...
our %config;

our $gitrepo;			# URL of git repo containing the source
our $lsbid;			# which distro (eg Ubuntu)
our $lsbrelease;		# which release of Ubuntu (eg 16.04)
our $cachedir;			# where to store local src eg /var/cache/minimaint

our $git = "/usr/bin/git";


# --- Global variables ------------------------------------------------------

# Computed later
our $perllibpath;
our $maintroot;

our $perlbin = "/usr/bin/perl";
our $scriptsubdir = 'maint';
our $maintscriptfile = 'maint';
our $scriptlock = 'maint-driver';

# --- Subroutines -----------------------------------------------------------

# The following subroutines run from BEGIN, which means they run even when
# syntax checking, and of course, long before we're allowed to use maint
# features!

#
# loadconfig();
#	load the compulsory configuration file..
#
sub loadconfig()
{
	my $configdir = "/etc/minimaint";
	$configdir = $ENV{MM_CONFIG_DIR} if defined $ENV{MM_CONFIG_DIR};
	my $file = "$configdir/info";
	my $text = read_file( $file ) ||
		die "minimaint: can't slurp config file $file\n";
	my $configdata = decode_json($text);
	#die Dumper $configdata;
	%config = %$configdata;

	$gitrepo = $config{gitrepo} || die "minimaint: no config gitrepo\n";
	$lsbid = $config{lsbid} || die "minimaint: no config lsbid\n";
	$lsbrelease = $config{lsbrelease} ||
		die "minimaint: no config lsbrelease\n";
	$cachedir = $config{cachedir} || die "minimaint: no config cachedir\n";
}


#
# fullclone( $giturl, $repodest );
#	blow the destination target dir away, fresh clone.
#
sub fullclone ($$)
{
	my( $giturl, $repodest ) = @_;

	print "Clone failed; retrying from first principles...\n";
	system("rm -rf $repodest");
	mkpath([$repodest], 0, 0755);
	chdir($repodest);
	system("$git clone --depth 1 --quiet $giturl $repodest") == 0 ||
		die "Clone still failed, failed\n";
}


#
# my $basedir = loadcache( $giturl, $repodest );
#	Synchronize our local cache from upstream via git,
#	given $giturl, the remote url to grab, and
#	$repodest, the path to store our local cache,
#	e.g. /var/cache/minimaint/.  Return the base dir of the local repo.
#
sub loadcache ($$)
{
	my( $giturl, $repodest ) = @_;

	# Sync our local git repository clone (blowing away what we've
	# already got if it turns out that something funny has
	# happened to upstream and we can't update simply.)

	unless ( -d $repodest )
	{
		mkpath([$repodest], 0, 0755);
	}

	-d $repodest || die "Cannot create directory $repodest\n";
	-w $repodest || die "directory $repodest not writable!\n";

	# If we don't have any local version of the repository at all,
	# create a new clone.
	unless( -e "$repodest/.git" )
	{
		print "Cloning maint repository to $repodest...\n";
		my $ret = system("$git clone --depth 1 --quiet $giturl $repodest");
		if( $ret )
		{
			# Clone failed.  Go nuclear:
			fullclone( $giturl, $repodest );
		}
	}

	# Update the current repository using a simple fast-forward strategy.
	chdir($repodest);
	my $ret = system("$git pull --quiet --ff-only");

	if( $ret )
	{
		# If the fast forward wasn't successful, go nuclear:
		fullclone( $giturl, $repodest );
	}
	return $repodest;
}


# Check that we're running the version of the operating system that we should
# be -- otherwise, abort post-haste!

sub check_os_version()
{
	my $actual_id = `/usr/bin/lsb_release -i -s`;
	chomp $actual_id;

	my $actual_release = `/usr/bin/lsb_release -r -s`;
	chomp $actual_release;

	unless( $actual_id eq $lsbid && $actual_release eq $lsbrelease )
	{
		die "Local operating system is '$actual_id $actual_release', ".
		    "not '$lsbid $lsbrelease'; aborting now\n".
		    "to avoid clobbering things I don't understand!\n";
	}
}

# Perform execution bootstrapping functions:
#  - Compute $maintroot and $perllibpath,
#  - Sync the local cache,
#  - Load the Sys::Maint libaries from that cache.

sub bootstrap() {
	# Make sure we're sitting somewhere safe.
	chdir("/");

	# set up our PATH to make sure life is sane
	$ENV{PATH} = '/bin:/sbin:/usr/sbin:/usr/bin:/usr/local/sbin:/usr/local/bin';
	unless ( -d $cachedir )
	{
		mkpath([$cachedir], 0, 0755);
	}

	print "Syncing local cache...\n";
	my $maintroot = loadcache( $gitrepo, $cachedir );

	#$perllibpath = File::Spec->catdir($maintroot, 'lib', 'perl');
#
	#unshift(@INC, $perllibpath); # Cannot use "use lib" directly
	#require Sys::Maint; import Sys::Maint qw(:all);
}

# Prior to this point, we haven't been able to refer to *any*
# Sys::Maint functions or constants.
# Let's read in the config information, check that we're running the correct
# OS, then run the bootstrap sequence *right now* so that we can.

#BEGIN {
loadconfig();
check_os_version();
bootstrap();
#}
